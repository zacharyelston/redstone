# Redstone Helm Chart Values
# Production-mirroring Kubernetes deployment configuration

global:
  imageRegistry: ""
  imagePullSecrets: []
  storageClass: ""

# Redmica (Redmine fork) Configuration
redmica:
  enabled: true
  image:
    repository: redmica/redmica
    tag: "latest"
    pullPolicy: IfNotPresent
  
  replicaCount: 1
  
  service:
    type: ClusterIP
    port: 3000
    targetPort: 3000
  
  ingress:
    enabled: true
    className: "nginx"
    annotations:
      nginx.ingress.kubernetes.io/rewrite-target: /
    hosts:
      - host: redstone.local
        paths:
          - path: /
            pathType: Prefix
    tls: []
  
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  
  env:
    - name: REDMINE_DB_ADAPTER
      value: "postgresql"
    - name: REDMINE_DB_HOST
      value: "redstone-postgresql"
    - name: REDMINE_DB_PORT
      value: "5432"
    - name: REDMINE_DB_DATABASE
      value: "redmica"
    - name: REDMINE_DB_USERNAME
      value: "redmica"
    - name: REDMINE_DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: redstone-postgresql
          key: postgres-password
    - name: REDMINE_SECRET_KEY_BASE
      valueFrom:
        secretKeyRef:
          name: redstone-secrets
          key: secret-key-base

# PostgreSQL Configuration (using Bitnami chart)
postgresql:
  enabled: true
  auth:
    postgresPassword: "redstone123"
    username: "redmica"
    password: "redmica123"
    database: "redmica"
  primary:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

# Redis Configuration (using Bitnami chart)
redis:
  enabled: true
  auth:
    enabled: false
  master:
    persistence:
      enabled: true
      size: 2Gi
    resources:
      limits:
        cpu: 250m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 128Mi

# LDAP Configuration
ldap:
  enabled: true
  image:
    repository: lldap/lldap
    tag: "latest"
    pullPolicy: IfNotPresent
  
  replicaCount: 1
  
  service:
    type: ClusterIP
    port: 3890
    targetPort: 3890
  
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi
  
  env:
    - name: LLDAP_HTTP_PORT
      value: "3890"
    - name: LLDAP_LDAP_PORT
      value: "3890"
    - name: LLDAP_JWT_SECRET
      valueFrom:
        secretKeyRef:
          name: redstone-secrets
          key: ldap-jwt-secret
    - name: LLDAP_LDAP_USER_PASS
      valueFrom:
        secretKeyRef:
          name: redstone-secrets
          key: ldap-admin-password

# Loki Configuration (using Grafana chart)
loki:
  enabled: true
  loki:
    auth_enabled: false
    commonConfig:
      replication_factor: 1
    storage:
      type: 'filesystem'
    schemaConfig:
      configs:
        - from: 2020-10-24
          store: boltdb-shipper
          object_store: filesystem
          schema: v11
          index:
            prefix: index_
            period: 24h
  singleBinary:
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi
    persistence:
      enabled: true
      size: 10Gi

# Grafana Configuration (using Grafana chart)
grafana:
  enabled: true
  adminPassword: "admin123"
  
  service:
    type: ClusterIP
    port: 3000
  
  ingress:
    enabled: true
    ingressClassName: nginx
    hosts:
      - grafana.local
    path: /
  
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  
  persistence:
    enabled: true
    size: 2Gi
  
  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
        - name: Loki
          type: loki
          access: proxy
          url: http://redstone-loki:3100
          isDefault: true
        - name: Prometheus
          type: prometheus
          access: proxy
          url: http://redstone-prometheus-server:80

# Prometheus Configuration (using Prometheus chart)
prometheus:
  enabled: true
  server:
    persistentVolume:
      enabled: true
      size: 8Gi
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi
  alertmanager:
    enabled: false
  pushgateway:
    enabled: false

# Logging Configuration
logging:
  # Enable Fluent Bit for log collection
  fluentBit:
    enabled: true
    image:
      repository: fluent/fluent-bit
      tag: "2.2.0"
    
    config:
      service: |
        [SERVICE]
            Daemon Off
            Flush 1
            Log_Level info
            Parsers_File parsers.conf
            Plugins_File plugins.conf
            HTTP_Server On
            HTTP_Listen 0.0.0.0
            HTTP_Port 2020
            Health_Check On
      
      inputs: |
        [INPUT]
            Name tail
            Path /var/log/containers/*.log
            multiline.parser docker, cri
            Tag kube.*
            Mem_Buf_Limit 50MB
            Skip_Long_Lines On
      
      filters: |
        [FILTER]
            Name kubernetes
            Match kube.*
            Kube_URL https://kubernetes.default.svc:443
            Kube_CA_File /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
            Kube_Token_File /var/run/secrets/kubernetes.io/serviceaccount/token
            Kube_Tag_Prefix kube.var.log.containers.
            Merge_Log On
            Keep_Log Off
            K8S-Logging.Parser On
            K8S-Logging.Exclude On
            Annotations Off
            Labels On
        
        [FILTER]
            Name modify
            Match kube.*
            Add service ${kubernetes['labels']['app.kubernetes.io/name']}
            Add component ${kubernetes['labels']['app.kubernetes.io/component']}
      
      outputs: |
        [OUTPUT]
            Name loki
            Match kube.*
            Host redstone-loki
            Port 3100
            Labels job=fluentbit, service=$service, component=$component
            Auto_Kubernetes_Labels On
